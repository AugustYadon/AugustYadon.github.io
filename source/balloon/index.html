<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Bootstrap Core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">

    <!-- Gif CSS  -->
    <link rel="stylesheet" type="text/css" href="/css/gifplayer.css">

    <!-- Custom CSS -->
    <link href="/css/business-casual.css" rel="stylesheet">
    <link href="/css/auggodoggo.css" rel="stylesheet">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Josefin+Slab:100,300,400,600,700,100italic,300italic,400italic,600italic,700italic" rel="stylesheet" type="text/css">

</head>
<body>
    <div id="subnav" class="hiddennav" style="height: 80px" ></div>
    <!-- Navigation -->
    <nav id="auggo-navbar" class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <!-- navbar-brand is hidden on larger screens, but visible when the menu is collapsed -->
                <a class="navbar-brand" style="height: 3em; padding: 0px;"  href="/"><img style="height: 3em; padding: 0px;" src="/img/AugDog.png"/></a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav"  >
                    <li><a class="auggo-toggle" style="height: 2.5em; padding: 0px; margin-top: -12px; margin-bottom: -5px"  href="/"><img style="height: 2.5em; padding: 0px;" src="/img/AugDog.png"/></a></li>
                    <li><a href="/about">About</a></li>
                    <li><div class="dropdown auggo-toggle">
                          <a href="/games"><button class="dropbtn" >games</button></a>
                          <div class="dropdown-content">
                            <a href="/games/plunker/">Plunker</a>
                            <a href="/games">Sweepyheads</a>
                          </div>
                        </div>
                        <a href="/games" class="auggo-detoggle">Games</a></li>
                    <li><div class="dropdown auggo-toggle">
                          <a href="/source"><button class="dropbtn" >Code Walkthrough</button></a>
                          <div class="dropdown-content">
                            <a href="/source/balloon/">Balloons</a>
                            <a href="/source/pathfinding/">Pathfinding</a>
                          </div>
                        </div>
                        <a href="/source" class="auggo-detoggle">Code Walkthrough</a></li>
                    <li><a href="/press-kit">Press Kit</a></li>
                    <li><a href="/contact">Contact</a></li>
                </ul>
            </div>
    </nav>

    <title>Auggo Doggo | Walkthrough | Balloon</title>
    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Jiggly Balloons</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <br>
                    <img class="img-responsive img-center" style="max-height: 600px; border-style: solid; border-width: 2px;" src="/img/balloon/jiggle.gif" />
                    <div class="row" style="font-size:14px">
                        <br><hr>
                        <h3 style="color: black">Focal Points - Game polish</h3>
                        <p> 
                            In any art-form, it's important to identify a focal point and spend extra time adding an appropriate amount of detail and work to it in order to bring life and personality to your project. In game development we call this "polish". You can polish every little part of your project until your eyes bleed but it's not going serve much purpose if you don't spend most of your time working on the foundations of your game. If you finish a piece of code and you're sure that it's not going to change much throughout the remainder of the game, you can polish early. Otherwise, try to put it off as long as you can. There are going to be times where you're going to toss entire game mechanics. It's obviously better not to polish those pieces until you've decided. It's all about timing, and no one is perfect at that, but everyone gets better with experience.
                        </p>
                        <p>
                            In VR, the focal points are usually objects you're able to pick up, or characters that interact with you. To make the player feel like there is something deeper than a flat lifeless 3D model, you should add animations, interaction scripts, and haptic feedback(controller vibration)*. For example, seeing swords collide with "clanking" sounds and physics is one thing, but to feel your sword grinding against a metal surface (or the increasing tension in your bowstring) is on another level. It's the layer of feedback that pushes you over the edge, where you allow yourself in a certain respect, to believe the ruse.
                        </p>
                        <img class="gif" style="max-height: 250px" data-gif="/img/balloon/labbow.gif" src="/img/balloon/labbow.png" />
                        <br>
                        <h3 style="color: black">What is important in a VR water balloon?</h3>
                        <p>
                            When you shake a balloon it should jiggle, it should deform from the water sinking on one side or the other based on gravity and how the player is tilting it, and it should pop in a satisfying way. Water balloons are satisfying to pop. Keep that in mind when you're designing things based on 'satisfying feelings', what is it that is satisfying, what is supposed to be enjoyable about this thing? 
                        </p>
                        <p>In this section I'm going to walk you through the parts of the water balloons in Plunker in 3 sections. 
                            <ul style="font-size: 14px">
                                <li>Creating the model, animations, and particle effects</li>
                                <li>Interaction with the SteamVR Plugin for holding/sloping/jiggling</li>
                                <li>Pop, respawn, throw, and deal damage to other objects</li>
                            </ul>
                        </p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>
<br> 
<br>   
<br>
    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Creating the look</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <div class="row" style="font-size:14px">
                        <h3 style="color: black">A quick note before we begin:</h3>
                        <p>Notice that everything we're doing is basically polish, but when I was first creating this balloon mechanic I grey-boxed everything first. "Grey-boxing is the traditional technique of blocking out the level with simple shapes to see if the level design supports the gameplay before creating the final art assets for the level". If you end up not liking how the scripts and interactions turn out, this is where you may decide to toss something. Try to always grey-box things first (or make very quick minimal models if you feel like you <i>need</i> to).</p>
                        <img class="gif" style="max-height: 500px" data-gif="/img/balloon/jigglebox.gif" src="/img/balloon/jigglebox.png" /><br>
                        <p>When beginning this balloon mechanic, I first thought of it as an interactive object which means that it has multiple states and transitions between them. The model we're creating below is what you hold and throw, most of the time it will be "popped" or basically non existent. We can talk more about the transitions and states in the 2nd section since they are mostly code. But just keep in mind that I'm only walking through this section first because it's more visually appealing for the walkthrough.</p>
                        <br> <br><hr> <br>
                        <h3 style="color: black">Making the model</h3>
                        <p>If you're not familiar with 3D modeling, it's not the end of the world, although it is a major limiting factor on your indie-dev life. I've toyed around with Blender (a free 3D modeling program) for about 3 years. It's fairly easy to learn how to make geometric or simple objects and I highly suggest making it a priority to understand the basics of 3D modeling. There isn't otherwise much to be said about this model. It's simple. One thing I might make note of is how many vertices this mesh has (around 750). If the balloon were a side object on a shelf or otherwise, I may have used less verts, but since it's going to deform, and it is a focal point of this section in Plunker, it's nice to have more.</p>
                        <div class="col-lg-6 "><img class="img-responsive img-center" style="max-height: 525px; border-style: solid; border-width: 2px;" src="/img/balloon/balloon-zmesh.png" /></div>
                        <div class="col-lg-6 "><img class="img-responsive img-center" style="max-height: 525px; border-style: solid; border-width: 2px;" src="/img/balloon/balloon-smoothmesh.png" /></div>
                    </div>
                    <div class="row" style="font-size:14px">
                        <br><br><br><br>
                        <h3 style="color: black">Bones and animations</h3>
                        <p><a href="https://en.wikipedia.org/wiki/Skeletal_animation">Rigging</a> is a term in game development that refers to adding bones to a 3D model. If you're not familiar with rigging, this is another important point I would highly suggest committing some time and energy into. You won't need to learn to the extents that I have, but if you have a basic understanding then you'll be able to work well on a team and communicate with artists on a better level.</p><br>
                        <img class="img-responsive img-center" style="max-height: 400px; border-style: solid; border-width: 2px;" src="/img/balloon/balloon-bones.png" />
                        <br>

                        <p>One notable thing you can see in this picture is how small the bones are. The ends don't even touch. This is because I'm mostly using <i>automatic weighting</i> and if the bones are smaller, the edges are more evenly weighted around the bone. This makes for easy animation when we need a body of water to jiggle around a central point. You can make animations in blender, but you'll want to use Mechanim&copy; in Unity to fine tune things. Either way its just a matter of making the bones scale and rotate in a way that looks satisfying. Once you've got that done, you'll have a pretty juicy looking balloon.</p>
                        <img class="gif" data-gif="/img/balloon/jiggle.gif" src="/img/balloon/jiggle.png" />

                        <h3 style="color: black">Particle System</h3>
                        <p>We'll want to create a popping animation to transition between a "<i>thrown</i> state" and a "<i>popped</i> state". The popped state won't have anything rendered at all, we'll just pretend that the water and the remaining rubber flew everywhere. The unity particle system is great for making animations like this, and it's usually necessary if you want to polish your game. There are several layers to our "sploosh" animation. There's the spray of water as it mists into the air, as well as the thicker explosion of water near the center. There's also a very quick flash of red balloon rubber. If you'd like to learn more about making particle systems <a href="https://www.youtube.com/watch?v=rR_bm8f8rVE">here</a> is where I learned a lot.</p>
                        <p> start with the central spray like this.</p><br>

                        <img class="gif" data-gif="/img/balloon/pop1.gif" src="/img/balloon/pop1.png" />

                        <br>
                        <p>Then you'll add a different type of splash particle. It's all about layering. Everything looks better with a few layers of different content.</p><br>
                        
                        <img class="gif" data-gif="/img/balloon/pop2.gif" src="/img/balloon/pop2.png" /><br>

                        <p>Once the splashes are in place, you'll want a flash of red rubber to bridge the gap of the balloon disappearing.</p><br>

                        <img class="gif" data-gif="/img/balloon/pop3.gif" src="/img/balloon/pop3.png" /> <br>

                        <p>Once all of the pieces are looking ok, you can put them together. (make sure to place them under each other in a hierarchy and simulate in world space so that they scale properly and they all play together at the same time - on wake).</p><br>
                        
                        <img class="gif" data-gif="/img/balloon/fullpop.gif" src="/img/balloon/fullpop.png" /><br>

                        <br>
                        <p>Layering and taking the extra time to tweak your particle systems can make parts of your game stand out in a memorable, striking way. This makes a massive difference to the look of the game, for little cost. <br>
                           <br>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>
<br> 
<br>   
<br>
    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Behavior Programming</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <div class="row" style="font-size:14px">
                        
                        <img class="gif" data-gif="/img/balloon/throwpop.gif" src="/img/balloon/throwpop.png" />
                        <br>
                        <h3 style="color: black">Where to start</h3>
                        <div class="col-lg-8">
                        <p>SteamVR has a plugin for Unity where they provide some C# example scripts that save a lot of effort and time. If you're writing your code in C# from scratch then you're wasting a lot of time. Instead I suggest altering the provided scripts to your needs. In our case we're simply taking advantage of the basic <i>Throwable.cs</i> and it's easy to access <i>OnPickup()</i> and <i>OnDrop()</i> events to call our own functions when the player grabs or lets go of the balloons. If you're making a VR game, you should study these scripts to understand how they're working. I go into more detail on VR interaction in the VR-Util guide.</p>
                        <p><b>OnPickUp()</b> calls a behavior function called SpawnBalloon(). This is because the balloon starts and ends in a sleep/popped state where it is an invisible object in a "balloon basket" waiting to be picked up.</p>
                        <p><b>OnDrop()</b> calls a behavior function called Throw(). This sets the balloon into a state where it knows that it has been thrown and it's only waiting for a collision to <i>pop</i> it.</p>
                        <p><b>Jiggle()</b> Triggers a jiggling animation on all of the fake balloons in the bucket to make it look like you interacted with the bucket itself.</p>
                        <p> Now I'll show you some of the code as examples</p>
                        </div>
                        <div class="col-lg-4 ">
                            <div class="img-responsive img-center"><img class="img-responsive img-center" style="max-height: 500px; border-style: solid; border-width: 2px;" src="/img/balloon/throwable-script.png" /></div>
                        </div>
                    </div>
                    <div class="row" style="font-size:14px">
                        <br>
                        
                        <h3 style="color: black">Grabbing and Throwing</h3>
                        <figure>
                            <figcaption id="example1-caption">Spawn() and Throw()</figcaption>
                            <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                <code  contenteditable="true" tabindex="0" spellcheck="false"
                                >public void SpawnBalloon()
{
    popped = false; //used to keep track of if the balloon is currently in a popped state
    thrown = false; anim.SetBool(thrown_bool, false); //used keep track of if the balloon is in a thrown state and the same thing but for the animator's use
    balloon_renderer.enabled = true; //Show the balloon 
    pop.SetActive(false); //deactivate popping so that it can be reactivated and "play on awake"
}

public void Throw()
{
    thrown = true; //used to keep track of if the balloon is currently in a thrown state
    anim.SetBool(thrown_bool, true); //same thing but for the animator
    anim.SetBool(smoothside_bool, false); //make sure balloon is not sloping to one side or another while thrown
    anim.SetBool(knotside_bool, false); // ||

    rb.isKinematic = false; //let the physics engine move the balloon non-kinematically 
    rb.angularVelocity = Random.insideUnitSphere * rb.velocity.sqrMagnitude/10f; //give it some random spin, this is satisfying
}</code>
                                </pre>
                            </figure>
                        <br>
                        <h3 style="color: black">Popping correctly</h3>
                        <figure>
                            <figcaption id="example1-caption">Pop()</figcaption>
                            <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                <code  contenteditable="true" tabindex="0" spellcheck="false"
                                >private void OnTriggerEnter(Collider col)
{
    if (!popped && thrown) //on collision, check whether or not balloon is in a poppable state
    {
        popped = true; thrown = false; anim.SetBool(thrown_bool, false); //update what state the balloon is in with bools and the animator
        StartCoroutine(Pop()); //we use a coroutine, this is just an asynchronous function that allows us to pop and then move the object when the balloon is finished popping.
        RecieveDamage rd = col.GetComponent<<i></i>RecieveDamage>(); //this looks for a script that would indicate that this is an enemy or destructible object.
        if (rd) { rd.Damage(); }
    }

}

IEnumerator Pop()
{
    pop.SetActive(true); //
    popsound.Play();
    yield return null;

    rb.isKinematic = true;
    rb.velocity = Vector3.zero;
    rb.angularVelocity = Vector3.zero;
    balloon_renderer.enabled = false;

    yield return new WaitForSeconds(1f);

    this.transform.position = barrel_script.balloon_slot.transform.position;
}</code>
                            </pre>
                        </figure>
                    </div>
                </div>
            </div>
        </div>
    </div>
<br><br><br>

    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Haptics</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <div class="row">

                        <h3 style="color: black">Playing satisfying audio clips</h3>
                        <p>Below you can hear the audio sound that is played. Satisfying.</p>

                        <audio class="img-center" controls>
                            <source src="/audio/splashballoon.mp3" type="audio/mpeg">
                            Your browser does not support the audio element.
                        </audio>

                        <h3 style="color: black">Jiggling with animation layers</h3>
                        <p>When you create a jiggle animation, you'll need to have an animation that can show the balloon jiggling without overriding any other animation states that are currently being used. For example we can used Unity's Mechanim to create animation layers to have the states blend. Say that you have an animation that stretches the balloon out one way or another and you also want to control when it jiggles separately. Well you can do that with layers. Since we're going to control jiggling independently of other animation states, we put it on it's own layer, and set it as an <i>additive</i> layer. We can then choose how much of that layer is blended.</p><br>
                        <img class="gif" data-mode="video" data-mp4="https://i.imgur.com/TZ4ydys.mp4" src="/img/balloon/jiggleblend.jpg" /> <br>
                        <p>If we only ever have one continuous jiggling animation, we can make the balloon infinitely jiggle on this layer and then change the layer weight to control how much jiggling gets blended in to the end result. This can be accessed and changed at runtime through code but above we can see the effect it will have by using the UI.</p>
                        <p>I'll show you our update loop for the balloon and you can see how we determine how much and how long we want to jiggle it.</p>
                        <figure>
                            <figcaption id="example1-caption">Update() - Part 1 - Jiggle weight</figcaption>
                            <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                <code  contenteditable="true" tabindex="0" spellcheck="false"
                                >void Update() {
    if (!popped && !thrown)
    {
        //calculate velocity and acceleration 
        current_pos = transform.position; 
        current_vel = (current_pos - last_pos) / Time.deltaTime;
        accel = (Vector3.Distance(last_vel, current_vel) * accel_factor) / Time.deltaTime;
        
        //Jiggle if an accel threshold is surpassed
        if (accel > accel_threshold) { jiggle_layer_weight = 0.7f; }

        //decrement jiggling until it's back to 0
        jiggle_layer_weight = Mathf.Clamp(jiggle_layer_weight - (.8f * Time.deltaTime), 0, 0.7f);
        anim.SetLayerWeight(1, jiggle_layer_weight);
        
        //prepare values for next frame
        last_pos = current_pos;
        last_vel = current_vel;</code>
                            </pre>
                        </figure>
                        <p>Since we move the balloon kinematically (by parenting it to the hand), we cannot get the velocity from the rigidbody, so we need to calculate it on our own with simple math and a few variables to keep track of displacement every frame. With this, we also calculate acceleration. If you recall, forces act on bodies in motion as a result of acceleration, so we'll only want to jiggle when there is a force jiggling the ballon (which is going to happen when the balloon moves or stops moving suddenly). When the acceleration surpasses a certain threshold we define, we can set the blend weight of our jiggling layer. We don't want this jiggling to turn off instantaneously, so we slowly decrease it until it is back to zero.</p>
                        <h3 style="color: black">Haptic Jiggle Vibration</h3>
                        <p>We already have a float variable <i>jiggle_layer_weight</i> that keeps track of how much our ballon is jiggling. If we use SteamVR's built in controller-vibration functions, it will be relatively easy to make it feel like the balloon is vibrating in your hands. Because we're using SteamVR's <i>Throwable.cs</i> script, we only have to access the correct hand and call a public function on it's <i>Hand.cs</i> Script. In the code below we've created a global variable, <i>hand</i>, that keeps track of which hand is holding the balloon. You'll want to set it when you grab the balloon and set it back to null when you let go as seen below. When you would update the animation weight, you'll also vibrate the controller by a propoertional amount. That's all there is to it. Such an easy step for what it accomplishes.</p>

                        <figure>
                            <figcaption id="example1-caption">Haptic Vibration Code Additions</figcaption>
                            <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                <code  contenteditable="true" tabindex="0" spellcheck="false"
                                >   //add these two lines to SpawnBalloon()
    if (Player.instance.leftHand.currentAttachedObject == this.gameObject) { hand = Player.instance.leftHand; }
    else if (Player.instance.rightHand.currentAttachedObject == this.gameObject) { hand = Player.instance.rightHand; }
    
    //put this in Throw()
    hand = null;

    //put this in Update() 
    if(hand && jiggle_layer_weight > 0) {hand.controller.TriggerHapticPulse((ushort)(jiggle_layer_weight*1000f)); }</code>
                            </pre>
                        </figure>
                        <br>
                        <hr>
                        <br>
                        <div class="row">
                            <div class="col-lg-5">
                                <h3 style="color: black">Deformation with Animation Layers</h3>
                                <p>The balloon now jiggles when you shake it and gives you some physical feedback. Great, we like this. The last bit will seal the deal, and make the balloon a satisfying bit of VR experience. In this part we'll make sure the balloon deforms somewhat realistically based on how you're holding it and the effects of gravity. Lets take another look at the Update() function that we used earlier. We'll add the following lines that reference the Animator's other layer. This is why we have layers, so that we can deform the balloon and ensure that the deformations are a base animation and that jiggling is an additive animation.</p>
                            </div>
                        
                            <div class="col-lg-7">
                                <img class="gif" data-mode="video" data-mp4="https://i.imgur.com/x2biFTs.mp4" src="/img/balloon/jiggle-hand.png" /> 
                            </div>
                        </div>
                        <br><br>
                        <figure>
                            <figcaption id="example1-caption">Update() - Part 2 - Orientation Deform</figcaption>
                            <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                <code  contenteditable="true" tabindex="0" spellcheck="false"
                                >        if (this.transform.forward.y > 0.15f)
        {
            anim.SetBool(smoothside_bool, true);
            anim.SetBool(knotside_bool, false);
        }
        else if (this.transform.forward.y < -0.15f)
        {
            anim.SetBool(smoothside_bool, false);
            anim.SetBool(knotside_bool, true);
        }
        else
        {
            anim.SetBool(smoothside_bool, false);
            anim.SetBool(knotside_bool, false);
        }
    }
}</code>
                            </pre>
                        </figure>
                    </div>
                    <div class="row">
                        <div class="col-lg-6">
                             <h3 style="color: black">Animator Variables</h3>
                            <p>Alone, this code senses what the upward component of our normalized <i>forward</i> vector points either up or down by a certain amount (0.15). It then sets state variables in the animator so that we can control the animations based on it's state. Is the knot side facing downward or is the smooth side facing downward or are they both pretty balanced? In these images you can see the parameters section of the animator is where we define the variables that we're referencing in our scripts. </p>
                            <br>
                            <h3 style="color: black">Animator State Transitions</h3>
                            <p>To show the primary logic drivers in the animators state machine, we'll look at the transition definitions in the third picture. You can find this view by clicking on one of the arrows between two states and then setting it up from there. If you have no transitions defined you have to create transitions.</p>
                            <br><br><br>
                            <h3 style="color: black">Animator State Diagram</h3>
                            <p>You can also see a state diagram that is extrordinarily simple since every since state can transition to every other state and all states are mutually exclusive at any one point in time. If you've been a software developer you can probably do a lot of this on your own without the UI based tools I present here. I'm showing you this because I did that for a year or two when I started out but I've learned that the more complex animations become more manageable with this sort of UI so long as you're not doing anything completely different than what this was made for.</p>
                        </div>
                        
                        <div class="col-lg-6" style="border-left: thin solid #444;">
                            <div class="row"><div class="img-center img-responsive"><img style="border-color: #444; border-width: 2px; border-style: solid" class="img-center img-responsive" src="/img/balloon/state-vars.png" /> </div></div> <br>
                            <div class="row"><div class="img-center img-responsive"><img style="max-height: 400px; border-color: #444; border-width: 2px; border-style: solid" class="img-center img-responsive" src="/img/balloon/state-transition.png" /> </div></div> <br>
                            <div class="row"><div class="img-center img-responsive"><img style="max-height: 150px; border-color: #444; border-width: 2px; border-style: solid" class="img-center img-responsive" src="/img/balloon/states.png" /> </div></div> <br>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
<br>
<br>
<br>
<br>
    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Polishing with Spawn Basket and environment interaction</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <div class="row">
                        <div class="col-sm-6">
                            <div class="row">
                                <h3 style="color: black">Spawn Basket</h3>
                                <p>I may have already mentioned this above, but when you've got a useable item like these water balloons, you don't want to instantiate a new prefab every single time the player grabs one, and you don't want to have a million instances of balloons laying around. The proper setup is keeping a few balloons in a deactivated state somewhere and activating them when they player needs one. This is why we have the <i>popped</i> state. </p>
                                <p>When the balloon is sitting in this basket, it is invisible and it has a collider that allows us to <i>spawn</i> the balloon. If you return to the code snippet above, spawning the balloon does a few things including enabling the renderer. This basket is also a reference to where the balloon should return once it finishes popping so that we can grab it again.</p> 

                            </div>
                        </div>
                        <div class="col-sm-6">
                            <div class="row"><br><br>
                            <img style="border-color: #444; border-width: 2px; border-style: solid" class="img-center img-responsive" src="/img/balloon/barreljiggle.png" />
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-6">
                            <div class="row">
                                <h3 style="color: black">Upgrade idea</h3>
                                <p>Since we only have two hands and we may want more buckets, we could rework this so that there are colliders on each basket that move the balloon into position and allow you to grab them so that we could have only two balloons present in the scene at any time rather than 2 per bucket. This is an extra exercise for you, and I may update it if I find it neccesary during development. Right now, I can't imagine having a few extra deactivated balloons causing any problems, but optimization is always fun if you have time.</p>
                            </div>
                        </div>
                        <div class="col-sm-6">
                            <div class="row"><br><br><br>
                            <img style="border-color: #444; border-width: 2px; border-style: solid" class="img-center img-responsive" src="/img/balloon/barrel-grab-jiggle.gif" />
                            </div>
                        </div>
                    </div>
                    <br><br>
                    <div class="row">
                        <div class="col-sm-6">
                            <div class="row">
                                <h3 style="color: black">Environment interactions</h3>
                                <p>In Plunker these water balloons were first thought up to be weapons against sand creatures. I had created a gun to kill large enemy creatures but quickly realized that I wanted them to be made of sand. I didn't feel like shooting sand with a gun was fun or satisfying, and a friend of mine threw out the idea that I should use water instead of bullets. So here I am with awesome balloons. I've reworked the minigun turret to have larger barrels and shoot balloons as well. Also Satisfying. The last bit of development I'd like to walk you through is how to make the balloons interact with specific game objects that are meant to do something when they are hit.</p>

                                <h3 style="color: black">Sending and Recieving Damage</h3>
                                <p>In order to execute a function upon colliding with an object you'll need to create a universal script that has a few universal functions to recieve damage. This will be a script that defines the skeleton of our <i>base class</i>. This portion of game dev is really fun because we get to take advantage of polymorphism. We can then specify another class specifically for our sand creature that will override our original functions so that no matter what is taking damage, the balloon can reference any class that derives from <i>RecieveDamage</i>.</p>
                                
                                <h3 style="color: black">Polymorphism</h3>
                                <p>Just to clear up what I mean by example: when the balloon collides with anything, we'll check if there is a script of type<<i>RecieveDamage</i>>. If there is a script of type<<i>SandBoy_RecieveDamage</i>> or type<<i>BreakableCrate_RecieveDamage</i>>, we will get a reference to them as long as they derive from type<<i>RecieveDamage</i>>. We'll be able to call public functions that appear in the base class. So if we call <i>SendDamage(500)</i> on the script, it may reduce the Sand Creatures health, or it could break a breakable box, depending on the overridden functions we write in the derived classes.I won't go into anymore detail here. </p>
                            </div>
                        </div>
                        <div class="col-sm-6">
                            <div class="row"><br><br><br>
                            <img style="border-color: #444; border-width: 2px; border-style: solid" class="img-center img-responsive" src="/img/balloon/barreljiggle.gif" />
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <p>Here we see the base class defined with only one <i>public virtual void</i> function. This makes our jobs easier if we make this function warn us that we're using it since our scripts will likely not want to reference this base class (although if we had a common piece of code we could put it in here and refernce it in the override.</p>
                        <figure>
                            <figcaption id="example1-caption">RecieveDamage.cs</figcaption>
                            <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                <code  contenteditable="true" tabindex="0" spellcheck="false"
                                >public class RecieveDamage : MonoBehaviour 
{    
    public virtual void Damage()
    {
        Debug.LogError(gameObject.name + "Has an undefined Damage() function.");
    }
}
</code>
                            </pre>
                        </figure>


                        <br>
                        <p>Next we see the subclass in our other script which has a little extra to show off why you may want to do this. I've defined an enum to contain specific places where the sandboy can be hit depending on which collider gets hit. I've chosen to serialize the field so that on the sand boy prefab I can put on of these scripts on each body part and set whether it's the head, leg, arms, etc. This way I can set it in the UI without leaving it accessible for code to access it as public. I've uysed a switch-case statement for my own readability to determine what should be done based on which part was hit. I have animations for the SandBoy to react when he is hit on different body parts, and its primary script keeps track of its health.</p>
                        <figure>
                            <figcaption id="example1-caption">RecieveDamage_Sandboy.cs</figcaption>
                            <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                <code  contenteditable="true" tabindex="0" spellcheck="false"
                                >public enum DamageZone { Head, Body, L_Arm, R_Arm, L_Leg, R_Leg }

public class RecieveDamage_Sandboy : RecieveDamage
{
    [SerializeField] DamageZone damage_zone;
    SandBoy sb;

    private void Start()
    {
        sb = transform.root.GetComponent<<i></i>SandBoy>();
        if (sb == null) { Debug.Log("Sandboy Script not found from Damage script attached to: " + this.name); }
    }

    public override void Damage()
    {
        switch (damage_zone)
        {
            case DamageZone.Head:
                sb.Damage(66);
                sb.anim.SetTrigger("Headshot");
                return;
            case DamageZone.Body:
                sb.Damage(33);
                sb.anim.SetTrigger("Bodyshot");
                return;
            case DamageZone.L_Leg:
                sb.Damage(25);
                sb.anim.SetTrigger("Bodyshot");
                return;
            case DamageZone.R_Leg:
                sb.Damage(25);
                sb.anim.SetTrigger("Bodyshot");
                return;
            case DamageZone.L_Arm:
                sb.Damage(25);
                sb.anim.SetTrigger("Arm_L_shot");
                return;
            case DamageZone.R_Arm:
                sb.Damage(25);
                sb.anim.SetTrigger("Arm_R_shot");
                return;
            default:
                sb.Damage(33);
                sb.anim.SetTrigger("Bodyshot");
                return;
        }
    }
}</code>
                            </pre>
                        </figure>
                        <p> I honestly could go deeper and continue writing about every facet of this entire game forever, but then I may never finish the game itself. This is the stopping point for now; I hope you learned a lot from following along and feel free to use whatever you can grab from this in any way you'd like, commercial or otherwise. Unless you're a dirty asset flipper and you're literally releasing a game where you hold and throw water balloons at walls. In which case I can't imagine it would sell well and I'm not worried about it hurting my project. Cheers.
                    </div>
                </div>
            </div>
        </div>
    </div>
<br>
<br>
<br>
<br>
    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Q&A</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <div class="row" style="font-size:16px">
                        <img class="img-responsive img-center" style="max-height: 400px;" src="/img/augdoglc.png" \>
                        <p>
                            If you felt any part of this guide was awkwardly paced, or hard to follow, please send me an email at <b>August@AuggoDoggoGames.com</b> and give me a chance to clear it up and improve at sharing my code creations. In the future, this is where I'll post answers to specific questions that aren't simply answered by updating a portion of the guide.
                        </p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>


    <footer>
        <div class="container">
            <div class="row">
                <div style="position: inherit" class="col-lg-12 text-center">
                    <p>Copyright &copy; Auggo Doggo Games 2018</p>
                </div>
            </div>
        </div>
    </footer>

    <!--  GIF js    -->
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/jquery.gifplayer.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>

    <!-- code display stuff -->
    <script type="text/javascript">
    (function()
    {
        for(var tags = ['main','figure','figcaption'], i = 0; i < tags.length; i ++)
        {
            document.createElement(tags[i]);
        }
    })();
    </script>
    <script type="text/javascript">
        (function(){
            if(typeof(window.getComputedStyle) == 'undefined') 
            { 
                return; 
            }
            var pre = document.getElementsByTagName('pre');
            for(var len = pre.length, i = 0; i < len; i ++)
            {
                var code = pre[i].getElementsByTagName('code').item(0);
                if(!code){code = pre[i].getElementsByTagName('samp').item(0);if(!code){continue;}}
                var column = document.createElement('div');
                column.setAttribute('aria-hidden', 'true');
                for(var n = 0; n < code.innerHTML.split(/[\n\r]/g).length; n ++)
                {
                    column.appendChild(document.createElement('span'));
                }
                pre[i].insertBefore(column, code);
                pre[i].className = 'line-numbers';
            }})();
    </script>

    <!-- navbarstuff -->
    <script type="text/javascript">
        // When the user scrolls the page, execute myFunction 
        window.onscroll = function() {myFunction()};
        // Get the navbar
        var navbar = document.getElementById("auggo-navbar");
        var navsub = document.getElementById("subnav");
        // Get the offset position of the navbar
        var sticky = navbar.offsetTop;
        // Add the sticky class to the navbar when you reach its scroll position. Remove "sticky" when you leave the scroll position
        function myFunction() {
          if (window.pageYOffset > sticky) {
            navbar.classList.add("sticky")
            navsub.classList.add("navsub")
            navsub.classList.remove("hiddennav")
          } else {
            navbar.classList.remove("sticky");
            navsub.classList.remove("navsub")
            navsub.classList.add("hiddennav")
          }
        }
    </script>

    <!-- gifplayer -->
    <script>
          $(document).ready( function() {
            $('.gif').gifplayer();
            setTimeout(function(){
              $('.share').fadeIn('slow');
            }, 1000);

          });
    </script>
</body>
</html>