<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Auggo Doggo | Source</title>

    <!-- Bootstrap Core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="/css/business-casual.css" rel="stylesheet">
    <link href="/css/auggodoggo.css" rel="stylesheet">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Josefin+Slab:100,300,400,600,700,100italic,300italic,400italic,600italic,700italic" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>


    <div id="subnav" class="hiddennav" style="height: 100px">
               
    </div>




    <!-- Navigation -->
    <nav id="auggo-navbar" class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <!-- navbar-brand is hidden on larger screens, but visible when the menu is collapsed -->
                <a class="navbar-brand" style="height: 3em; padding: 0px;"  href="/"><img style="height: 3em; padding: 0px;" src="/img/AugDog.png"/></a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav"  >
                    <li>
                        <a class="auggo-toggle" style="height: 2.5em; padding: 0px; margin-top: -20px; margin-bottom: -5px"  href="/"><img style="height: 2.5em; padding: 0px;" src="/img/AugDog.png"/></a>
                    </li>
                    <li>
                        <a href="/about">About</a>
                    </li>
                    <li>
                        <div class="dropdown auggo-toggle">
                          <a href="/games"><button class="dropbtn" >games</button></a>
                          <div class="dropdown-content">
                            <a href="/games/plunker/">Plunker</a>
                            <a href="/games/sweepyheads/">Sweepyheads</a>
                          </div>
                        </div>
                        <a href="/games" class="auggo-detoggle">Games</a>
                    </li>
                    <li>
                        <div class="dropdown auggo-toggle">
                          <a href="/source"><button class="dropbtn" >Source Code</button></a>
                          <div class="dropdown-content">
                            <a href="/source/balloon/">Balloons</a>
                            <a href="/source/pathfinding/">Pathfinding</a>
                            <a href="/source/terrain-models/">Terrain Model</a>
                            <a href="/source/vr-utils/">VR Util</a>
                          </div>
                        </div>
                        <a href="/source" class="auggo-detoggle">source code</a>
                    </li>
                    <li>
                        <a href="/press-kit">Press Kit</a>
                    </li>
                    <li>
                        <a href="/contact">Contact</a>
                    </li>
                    <!--li>
                        <a href="http://Twitch.tv/AuggoDoggo">Twitch<img class="twitchLog" data-twitch-channel="auggodoggo"></a>
                    </li -->
                </ul>
            </div>
            <!-- /.navbar-collapse -->

        <!-- /.container -->
    </nav>
    

<div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Pathfinding</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <br>
                    <img class="img-responsive img-center" style="max-height: 600px; border-style: solid; border-width: 2px;" src="/img/pathfinding/nodeintro.png" />
                    <div class="row" style="font-size:18px">
                        <br><hr>
                        <h3 style="color: black">Intro</h3>
                        <p>If you'd like to use a pathfinding algorithm that uses minimal realtime processing power, and you've got a bit of programming experience, this is a great place to both learn and snag a sharp piece of a code for your 3D game. If you can't follow everything I'm posting here, then feel free to contact me and ask questions. All code here is 100% free to use for any purpose. If you'd like to support me, tell your friends about Plunker, and buy it!
                        </p>

                        <h3 style="color: black">Features</h3>
                        <p>This code builds a network of connected nodes that are processed as waypoints for the fastest path from node <i>A</i> to node <i>B</i>. Every single path from every node to every other node will be stored in an array. This way, you can pre-process the fastest paths and then look them up often without burning processing power. Almost immediately after booting, you can query the <i>Node Network</i> for the fastest path between two transforms that can readily see one of the nodes. In other words, if your player is in a maze, running from enemies, the enemy can call NodeNetwork.FastestPath(Player.transform, Enemy.transform) some raycasting will be done to determine which nodes are visible to the player character and the enemy character. The output is an array of waypoints that you can use in your enemy script.
                        </p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>

   <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">How it works</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <br>
                    <img class="img-responsive img-center" alt="Creating empty game objects to serve as nodes - pink cubes added to them for visibility" style="max-height: 600px; border-style: solid; border-width: 2px;" src="/img/pathfinding/pinknodes.png" />
                    <div class="row" style="font-size:14px">
                        <br><hr>
                        <h3 style="color: black">Theory - Dijkstra</h3>
                        <p>When finding the fastest path in a 3D environment, one may hear mention of something called <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A-Star search algorithms</a>. This is an abstract extension of Dijkstra's algorithm for finding the fastest path between two nodes using heuristics. I'm going to focus on my own implementation of <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"> Dijkstra's Algorithm</a>. School teaches you algoritms like these in a conceptual way, but often you realize that the concepts require a lot of work to apply to real life niche solutions. Dijkstra wasn't thinking of massive sand creatures navigating a maze to hunt down a player character on their own, but because his conceptual algorithm is abstract and vague, it can be applied to many things with some thought and work. I won't explain <i>Dijkstra's</i> in detail, since there's an entire wikipedia page that explains it.<br><br>
                            <img class="img-responsive img-center" style="max-height: 600px; border-style: solid; border-width: 2px;" src="/img/pathfinding/dijkstra.gif" \>
                        </p>
                        <h3 style="color: black">Application</h3>
                        <p>To apply these ideas to our implementation the first thing we need is a formal <b>reference</b> to everything we are using in our algorithms. The DijkNode (below) is a way to capture all information in a convenient chunk of data (Notice at the bottom of the code sample we define a 2D array). Our 2D array can be thought of as a lookup table where the first row (newwork[0,x]) will be a list of DijkNodes that contain info on each nodes relation to node 0. If this is confusing I will explain it further. <br>
                        <br>
                        <i>network[0,1]</i> is a single Dijknode. Each Dijknode stored in the first row (network[<b>0</b>,<i>somenumber</i>]) has information on that <b>x</b> node only as it relates to the <b>0th</b> node. In otherwords <b>network[4,9].min_dist</b> would tell you the minimum distance that it would take to get <i>to</i> the 9th node <i>from</i> the 4th node. So once we've filled out this entire 2D array we will be able to look up the fastest path between two nodes in terms of waypoints of other nodes. Example of how you would grab the fastest path is at the bottom, it won't work until we've constructed a network and filled the 2D array out though. This is where Dijkstra's algorithm comes in, we would implement it to fill in our data table.</p>
                        <p>
                            <figure>
                                <figcaption id="example1-caption">DijkNode</figcaption>
                                <pre aria-describedby="example1-description" aria-labelledby="example1-caption">
                                    <code  contenteditable="true" tabindex="0" spellcheck="false"
                                    >struct DijkNode
{
    public List<<i></i>int> nodes; //List of indicies of nodes that have physically unblocked line of sight to this referenced node
    public Transform trans; //Transform is used for a point in worldspace but a Vector3 is a fair replacement for a simple implementation
    public bool finalized;  //To mark that this node's min_dist has been finalized for certain
    public float min_dist;  //The total distance of the minimum set of nodes between Start(this row) and Finish(this node)
    public List<<i></i>Transform> min_path; //The actual list of nodes, in order, forming the shortest path between Start(this row) and Finish(this node)
}

DijkNode[,] network;

//would access this for stored/processed info
//Transform[] fastest_path_between_start_and_finish = network[start_node_index,finish_node_index].min_path.toArray();</code>
                                </pre>
                            </figure>
                        </p><br>
                        <p> If you look back at this image, you'll see all of the <b>nodes</b> (empty game objects with pink cubes added for visibility) that I've placed in the stone/sand maze in Plunker. These are hand placed but at the end of this guide, I'll explain how one would automate the node placement.
                        </p>
                        <p><img class="img-responsive img-center" alt="Creating empty game objects to serve as nodes - pink cubes added to them for visibility" style="max-height: 250px; border-style: solid; border-width: 2px;" src="/img/pathfinding/pinknodes.png" />
                        </p>
                        <p>In order to fill in our DijkNode table with an algorithm, we need the transforms of these as well as a way to see which nodes "connect" directly. If we can reference these, then we can literally achieve everything else through our algorithms. Below I'll place an image of a visualisation of all node connections</p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>
    
    

    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Suggestions and ideas for Alteration</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <br>
                    <div class="row" style="font-size:16px">
                        <br><hr>
                        <h3 style="color: black">Multi-target pathfinding</h3>
                        <p>find closest target and chase them
                        </p>

                        <h3 style="color: black">multi-type paths between nodes</h3>
                        <p>upon connection of nodes, denote if it crosses water or leaps over a short wall, and then different character types can access diffferent path dbs
                        </p>

                        <h3 style="color: black">static vs non-static nodes</h3>
                        <p>Add a function that rebuilds smaller parts of the network whenever a non-static node moves (use .nodes to find which other nodes to change)
                        </p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>





 
    <footer>
        <div class="container">
            <div class="row">
                <div style="position: inherit" class="col-lg-12 text-center">
                    <p>Copyright &copy; Auggo Doggo Games 2018</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery --> 
    <script src="/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/js/ekko-lightbox.min.js"></script>

    <!-- Script to Activate the Carousel -->
    <script>
    $('.carousel').carousel({
        interval: 5000 //changes the speed
    })
    </script>

    <script type="text/javascript">
        $(document).on('click', '[data-toggle="lightbox"]', function(event) {
            event.preventDefault();
            $(this).ekkoLightbox();
        });
        $.fn.ekkoLightbox.defaults;
    </script>


    <script type="text/javascript">
    (function()
    {
        for(var tags = ['main','figure','figcaption'], i = 0; i < tags.length; i ++)
        {
            document.createElement(tags[i]);
        }
    })();
    </script>

<script type="text/javascript">
    (function()
    {
        if(typeof(window.getComputedStyle) == 'undefined') 
        { 
            return; 
        }
        
        var pre = document.getElementsByTagName('pre');
        
        for(var len = pre.length, i = 0; i < len; i ++)
        {
            var code = pre[i].getElementsByTagName('code').item(0);
            if(!code)
            {
                code = pre[i].getElementsByTagName('samp').item(0);
                if(!code)
                {
                    continue;
                }
            }
            
            var column = document.createElement('div');
            column.setAttribute('aria-hidden', 'true');
            
            for(var n = 0; n < code.innerHTML.split(/[\n\r]/g).length; n ++)
            {
                column.appendChild(document.createElement('span'));
            }
            
            pre[i].insertBefore(column, code);
            pre[i].className = 'line-numbers';
        }   
    
    })();
    </script>

    <script type="text/javascript">
        // When the user scrolls the page, execute myFunction 
        window.onscroll = function() {myFunction()};

        // Get the navbar
        var navbar = document.getElementById("auggo-navbar");
        var navsub = document.getElementById("subnav");

        // Get the offset position of the navbar
        var sticky = navbar.offsetTop;

        // Add the sticky class to the navbar when you reach its scroll position. Remove "sticky" when you leave the scroll position
        function myFunction() {
          if (window.pageYOffset > sticky) {
            navbar.classList.add("sticky")
            navsub.classList.add("navsub")
            navsub.classList.remove("hiddennav")
          } else {
            navbar.classList.remove("sticky");
            navsub.classList.remove("navsub")
            navsub.classList.add("hiddennav")
          }
        }
    </script>

</body>

</html>
