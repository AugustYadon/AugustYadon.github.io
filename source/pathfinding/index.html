<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Auggo Doggo | Source</title>

    <!-- Bootstrap Core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="/css/business-casual.css" rel="stylesheet">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Josefin+Slab:100,300,400,600,700,100italic,300italic,400italic,600italic,700italic" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>


    <div id="subnav" class="hiddennav" style="height: 140px">
               
    </div>




    <!-- Navigation -->
    <nav id="auggo-navbar" class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <!-- navbar-brand is hidden on larger screens, but visible when the menu is collapsed -->
                <a class="navbar-brand" style="height: 3em; padding: 0px;"  href="/"><img style="height: 3em; padding: 0px;" src="/img/AugDog.png"/></a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav"  >
                    <li>
                        <a class="auggo-toggle" style="height: 3em; padding: 0px;"  href="/"><img style="height: 3em; padding: 0px;" src="/img/AugDog.png"/></a>
                    </li>
                    <li>
                        <a href="/about">About</a>
                    </li>
                    <li>
                        <div class="dropdown auggo-toggle">
                          <a href="/games"><button class="dropbtn" >games</button></a>
                          <div class="dropdown-content">
                            <a href="/games/plunker/">Plunker</a>
                            <a href="/games/sweepyheads/">Sweepyheads</a>
                          </div>
                        </div>
                        <a href="/games" class="auggo-detoggle">Games</a>
                    </li>
                    <li>
                        <div class="dropdown auggo-toggle">
                          <a href="/source"><button class="dropbtn" >Source Code</button></a>
                          <div class="dropdown-content">
                            <a href="/source/balloon/">Balloons</a>
                            <a href="/source/pathfinding/">Pathfinding</a>
                            <a href="/source/terrain-models/">Terrain Model</a>
                            <a href="/source/vr-utils/">VR Util</a>
                          </div>
                        </div>
                        <a href="/source" class="auggo-detoggle">source code</a>
                    </li>
                    <li>
                        <a href="/press-kit">Press Kit</a>
                    </li>
                    <li>
                        <a href="/contact">Contact</a>
                    </li>
                    <!--li>
                        <a href="http://Twitch.tv/AuggoDoggo">Twitch<img class="twitchLog" data-twitch-channel="auggodoggo"></a>
                    </li -->
                </ul>
            </div>
            <!-- /.navbar-collapse -->

        <!-- /.container -->
    </nav>
    
    

<div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Pathfinding</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <br>
                    <img class="img-responsive img-center" style="max-height: 600px; border-style: solid; border-width: 2px;" src="/img/pathfinding/nodeintro.png" />
                    <div class="row" style="font-size:18px">
                        <br><hr>
                        <h3 style="color: black">Intro</h3>
                        <p>If you'd like to use a pathfinding algorithm that uses minimal realtime processing power, and you've got a bit of programming experience, this is a great place to both learn and snag a sharp piece of a code for your 3D game. If you can't follow everything I'm posting here, then feel free to contact me and ask questions. All code here is 100% free to use for any purpose. If you'd like to support me, tell your friends about Plunker, and buy it!
                        </p>

                        <h3 style="color: black">Features</h3>
                        <p>This code builds a network of connected nodes that are processed as waypoints for the fastest path from node a to node b. Every single path from every node to every other node will be stored in an array. This way, you can pre-process the fastest paths and then look them up often without burning processing power. Almost immediately after booting, you can query the <i>Node Network</i> for the fastest path between two transforms that can readily see one of the nodes. In other words, if your player is in a maze, running from enemies, the enemy can call NodeNetwork.FastestPath(Player.transform, Enemy.transform) some raycasting will be done to determine which nodes are visible to the player character and the enemy character. The output is an array of waypoints that you can use in your enemy script.
                        </p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>

   <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Pathfinding</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <br>
                    <img class="img-responsive img-center" style="max-height: 600px; border-style: solid; border-width: 2px;" src="/img/pathfinding/nodeintro.png" />
                    <div class="row" style="font-size:18px">
                        <br><hr>
                        <h3 style="color: black">Intro</h3>
                        <p>If you'd like to use a pathfinding algorithm that uses minimal realtime processing power, and you've got a bit of programming experience, this is a great place to both learn and snag a sharp piece of a code for your 3D game. If you can't follow everything I'm posting here, then feel free to contact me and ask questions. All code here is 100% free to use for any purpose. If you'd like to support me, tell your friends about Plunker, and buy it!
                        </p>

                        <h3 style="color: black">Features</h3>
                        <p>This code builds a network of connected nodes that are processed as waypoints for the fastest path from node a to node b. Every single path from every node to every other node will be stored in an array. This way, you can pre-process the fastest paths and then look them up often without burning processing power. Almost immediately after booting, you can query the <i>Node Network</i> for the fastest path between two transforms that can readily see one of the nodes. In other words, if your player is in a maze, running from enemies, the enemy can call NodeNetwork.FastestPath(Player.transform, Enemy.transform) some raycasting will be done to determine which nodes are visible to the player character and the enemy character. The output is an array of waypoints that you can use in your enemy script.
                        </p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>
    
    

    <div class="container">
        <div class="row">
            <h2 class="intro-text text-left" id="auggoH2">Pathfinding</h2>
            <div class="box">
                <div class="col-lg-12 ">
                    <br>
                    <img class="img-responsive img-center" style="max-height: 600px; border-style: solid; border-width: 2px;" src="/img/pathfinding/nodeintro.png" />
                    <div class="row" style="font-size:18px">
                        <br><hr>
                        <h3 style="color: black">Intro</h3>
                        <p>If you'd like to use a pathfinding algorithm that uses minimal realtime processing power, and you've got a bit of programming experience, this is a great place to both learn and snag a sharp piece of a code for your 3D game. If you can't follow everything I'm posting here, then feel free to contact me and ask questions. All code here is 100% free to use for any purpose. If you'd like to support me, tell your friends about Plunker, and buy it!
                        </p>

                        <h3 style="color: black">Features</h3>
                        <p>This code builds a network of connected nodes that are processed as waypoints for the fastest path from node a to node b. Every single path from every node to every other node will be stored in an array. This way, you can pre-process the fastest paths and then look them up often without burning processing power. Almost immediately after booting, you can query the <i>Node Network</i> for the fastest path between two transforms that can readily see one of the nodes. In other words, if your player is in a maze, running from enemies, the enemy can call NodeNetwork.FastestPath(Player.transform, Enemy.transform) some raycasting will be done to determine which nodes are visible to the player character and the enemy character. The output is an array of waypoints that you can use in your enemy script.
                        </p>
                    </div>
                </div>
                <br/>
            </div>
        </div>
    </div>





 
    <footer>
        <div class="container">
            <div class="row">
                <div style="position: inherit" class="col-lg-12 text-center">
                    <p>Copyright &copy; Auggo Doggo Games 2018</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery --> 
    <script src="/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/js/bootstrap.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/js/ekko-lightbox.min.js"></script>

    <!-- Script to Activate the Carousel -->
    <script>
    $('.carousel').carousel({
        interval: 5000 //changes the speed
    })
    </script>

    <script type="text/javascript">
        $(document).on('click', '[data-toggle="lightbox"]', function(event) {
            event.preventDefault();
            $(this).ekkoLightbox();
        });
        $.fn.ekkoLightbox.defaults;
    </script>

    <!-- Twitch live components 
    <script data-interval="60" data-offline-image="/img/twitchlogo_offline_wtext.png" data-online-image="/img/twitchlogo_online.gif" src="/js/twitch-channel-status.js"></script>
    -->

    <script type="text/javascript">
        // When the user scrolls the page, execute myFunction 
        window.onscroll = function() {myFunction()};

        // Get the navbar
        var navbar = document.getElementById("auggo-navbar");
        var navsub = document.getElementById("subnav");

        // Get the offset position of the navbar
        var sticky = navbar.offsetTop;

        // Add the sticky class to the navbar when you reach its scroll position. Remove "sticky" when you leave the scroll position
        function myFunction() {
          if (window.pageYOffset > sticky) {
            navbar.classList.add("sticky")
            navsub.classList.add("navsub")
            navsub.classList.remove("hiddennav")
          } else {
            navbar.classList.remove("sticky");
            navsub.classList.remove("navsub")
            navsub.classList.add("hiddennav")
          }
        }
    </script>

</body>

</html>
